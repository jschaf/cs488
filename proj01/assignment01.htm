<html>

<!-- #BeginTemplate "../../main.dwt" -->

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<!-- #BeginEditable "doctitle" -->
<title>CS488 - Discrete Event Simulatio</title>
<style type="text/css">
.style1 {
	color: #FF0000;
}
</style>
<!-- #EndEditable -->
<link rel="stylesheet" type="text/css" href="../../styles/main.css">
</head>

<body>

<h1>CS488 - Discrete Event Simulation</h1>
<p>
<!--webbot bot="Navigation" S-Type="sequence" S-Orientation="horizontal" S-Rendering="graphics" B-Include-Home="TRUE" B-Include-Up="FALSE" U-Page="sid:1001" startspan --><nobr>[&nbsp;<a href="../../index.htm" target="">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../schedule.htm" target="">Schedule</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../teams08.htm" target="">Programming&nbsp;Pairs</a>&nbsp;]</nobr><!--webbot bot="Navigation" i-checksum="10191" endspan -->
<!--webbot bot="Navigation" S-Orientation="horizontal" S-Rendering="graphics" S-Type="top" B-Include-Home="FALSE" B-Include-Up="FALSE" startspan --><!--webbot bot="Navigation" i-checksum="0" endspan --></p>
<!-- #BeginEditable "body" -->
<h2>Project 1 - Scanning and Parsing</h2>
<p><font color="#FF0000"><b><i>See Course Schedule for due date!</i></b></font></p>
<p>Your programming pair (or just you if you are working alone) will build a 
scanner and parser for the MIEDS language.</p>
<ul>
	<li>The scanner must correctly convert an input file to a sequence of MIEDS 
	tokens.&nbsp; Your key references are the MIEDS specification document <b>
	<a href="MIEDs.pdf">mieds.pdf</a></b> and the equivalent grammars in <b>
	<a href="Grammar.pdf">grammar.pdf</a></b>.</li>
	<li>You are given some items that will assist in writing your scanner and 
	testing it:<ul>
		<li><b>scanner.ads</b> has the specification for the scanner. This 
		follows the pattern of TL, which we studied in Lesson 2. There is also a 
		procedure to read the entire contents of file into a string. This is 
		what the scanner expects for input. Finally, there is a procedure to 
		print a token in a standard format.&nbsp; You are required to use this 
		to test your scanner.</li>
		<li><b>scanner.adb</b> contains a &quot;stub&quot; for the scanner procedure, plus 
		complete implementations of two other procedures.&nbsp; You can 
		assume these two implementations are correct and complete.&nbsp; (But 
		please report any bugs you find immediately.)&nbsp; They are also quite 
		short.&nbsp; You should study them.</li>
		<li><b>scanner_develop.adb</b> is a test harness for the scanner. You'll 
		compile this along with <b>scanner.ads</b> and <b>scanner.adb</b> to 
		make an executable program.</li>
		<li><b>example.sim</b> contains a MIEDS program. The first line also 
		includes a few illegal tokens for scanner testing.</li>
		<li><b>scanner_example.txt</b> contains the output that <b>
		scanner_develop</b> should produce when your scanner is complete and 
		correct.</li>
	</ul>
	</li>
	<li><strong>You are required to use the &quot;goto&quot; style of scanner 
	implementation</strong>.&nbsp; Note the TL scanner is &quot;ad hoc.&quot;&nbsp; An ad 
	hoc scanner does not meet the requirement.&nbsp; In class we also discussed 
	a handout with the state variable form of a scanner.&nbsp; This also does 
	not meet the requirementment.&nbsp; Use goto's.</li>
	<li><b><i>Illegal tokens</i>:</b> Here is how to handle invalid inputs.&nbsp; 
	When the scanner is in the start state and encounters a &quot;bad character,&quot; one 
	that cannot possibly begin a valid MIEDS token, that character alone is 
	considered to be an illegal token, which should be returned as
	<font face="Courier New">Illegal_Token</font>.&nbsp; When the scanner has 
	already seen at least one valid character that is part of an identifier or a 
	number, then it encounters a bad character, it should consider all 
	characters in the token so far, plus the bad character, plus all other 
	characters up to (but not including) the next space, tab (HT), line feed 
	(LF), or end of input ($) to be part of the illegal token.</li>
	<li><i><b>Line numbers:</b></i>&nbsp; Your MIEDS scanner is expected to 
	increment the parameter Line_Number each time it sees a linefeed (LF) 
	character.&nbsp; Since the caller is expected to initialize Line_Number at 
	1, it will always reflect the correct source line number of the token 
	returned.</li>
	<li>Your scanner will be evaluated by compiling and running it in the test 
	frame and comparing its output to the output of the same scanner that 
	generated <b>scanner_example.txt</b>.&nbsp; The input files used for 
	evaluation will be similar to the provided <b>example.sim</b>, but not 
	identical.</li>
	<li>For the parser, there are also some helpful initial files:<ul>
		<li><b>parser.ads</b> has the specification for the parser. This follows 
		the pattern of TL, which we studied in Lesson 2.&nbsp; </li>
		<li><b>parser.adb</b> has a skeleton that is very similar to the TL 
		parser's design.&nbsp; The same debugging print procedure used for TL in 
		Lesson 2 is also provided. You will have to include calls to this 
		procedure in your parser in order to generate the required trace output.&nbsp; 
		<span class="style1">There is absolutely no guarantee that the provided stubs for parsing 
		procedures are correct.&nbsp;</span> Throw them away if you do 
		not like them.</li>
		<li><b>parser_develop.adb</b> is a test harness for the parser. You'll 
		compile this along with <b>parser.ads</b> and <b>parser.adb</b> to make 
		an executable program.</li>
		<li><b>parser_example.txt</b> contains the output that <strong>parser</strong><b>_develop</b> should produce when your scanner is complete and 
		correct.&nbsp; The input to the parser was <b>example.sim</b> given for 
		the scanner test with the first line containing illegal tokens 
		&quot;commented out,&quot; i.e with &quot;--&quot; inserted at the start of the line.</li>
	</ul>
	</li>
	<li><b>Syntax errors:</b>&nbsp; Any syntax errors discovered by your parser 
	must be recognized by raising the Syntax_Error exception provided in the 
	parser spec.&nbsp; An appropriate &quot;with&quot; string should be included to 
	indicate the nature of the error.</li>
	<li>Your parser will be evaluated by compiling and running it in the test 
	frame and comparing its output to the output of the same parser that 
	generated <b>parser_example.txt</b>.&nbsp; The input files used for 
	evaluation will be similar to the provided <b>example.sim</b>, but not 
	identical.&nbsp; Inputs with various syntax errors will be included.</li>
	<li>You can use any implementation technique you like: <b>recursive descent, 
	DPDA, or ayacc</b>.</li>
</ul>
<h3>Observation</h3>
<ul>
	<li>This is is a realistic assignment for a programming pair working on a 
	real simulator project.&nbsp; Creating the test harnesses might be part of 
	the assignment rather than provided by someone else.&nbsp; A skilled team 
	would knock this project out in a day or less.</li>
</ul>
<h3>Grades</h3>
<ul>
	<li>This project is worth 130 points, 13% of the course.&nbsp; The scanner 
	and parser are equally weighted.&nbsp; Perfectly functional implementations 
	(i.e. those that produce good outputs) will receive a minimum grade of 89% 
	(B+).&nbsp; The remaining grade will be based on readability of your code, 
	including comments.&nbsp; The A+ standard for readability is the code of the 
	TL implementation.</li>
</ul>
<h3>Hints</h3>
<ul>
	<li><b><i>Do not attempt to &quot;cold code&quot; the entire scanner or parser with 
	zero testing, then begin debugging</i></b>. This is a recipe for lost sleep 
	and great frustration. Instead, develop a strategy to implement a few tokens 
	or grammar rules at a time and test as you go.&nbsp; This is all about 
	choosing an order to write the code that gets you to a runnable version as 
	quickly as possible.&nbsp; Then add, compile, and test, add, compile, and 
	test, add, compile and test...</li>
	<li>A reasonable approach to the project is to have one member of the 
	programming pair study each set of provided files and develop a strategy for 
	coding that will allow incremental testing as you go along. The other 
	partner can focus on studying the details of MIEDS tokens and grammar, 
	developing a DFA, left-factoring and removing left recursion from the 
	grammar.&nbsp; Then get together to wail away on code.</li>
	<li>Look up the Linux command <b>diff</b>. This is extremely useful for 
	comparing your programs' outputs to the example files. If you are working in 
	Windows, I can show you where to find a Windows version.&nbsp; <i><b>Highly 
	recommended!</b></i></li>
	<li>Since we have not emphasized DPDA or ayacc techniques, they will require 
	some extra learning on your part if you decide to use them.&nbsp; Bear in 
	mind that future projects will be based on a 
	recursive descent parser.</li>
	<li>Efficiency is fairly important in a scanner. You should not do any 
	compute-intensive operations on each character of input.&nbsp; You should 
	also be reasonably careful for any operation that happens once per token 
	(like looking up keywords).</li>
	<li>Don't be too concerned with details of efficiency or elegance in your parser.&nbsp; The 
	code you write here will change a great deal in project 2 when actions are 
	added.</li>
</ul>
<!-- #EndEditable -->

</body>

<!-- #EndTemplate -->

</html>
