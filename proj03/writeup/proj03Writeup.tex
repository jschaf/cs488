\documentclass[12pt,letterpaper,titlepage]{article}

\pdfpagewidth 8.5in
\pdfpageheight 11in 

% 1in margins
\usepackage[vmargin={1.6in, 0.3in}, hmargin={1in, 1in}]{geometry}
\usepackage{eulervm}
\usepackage{setspace}
\usepackage{fancyhdr}


% Minion support
% \usepackage[opticals,minionint,textosf,mathlf]{MinionPro}

% XeTeX
% \usepackage{fontspec}
% \usepackage{xunicode,xltxtra}


\usepackage{underscore}
% To get proper looking page headers
\setlength{\voffset}{-0.5in}
\setlength{\headsep}{12pt}
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\renewcommand\headrulewidth{0pt}
\fancyhead[R]{Schafer \thepage}

% % Line order is important for these
% \defaultfontfeatures{Scale=MatchLowercase,Mapping=tex-text}
% \setromanfont[Ligatures={Common}]{Adobe Garamond Pro}
% \setsansfont{Akzidenz Grotesk Roman} 
% \setmonofont[Scale=0.8]{Consolas}

% Use diffferent styles for section headings
\usepackage{sectsty} 
\sectionfont{\sffamily\mdseries\large} 
\subsectionfont{\rmfamily\mdseries\scshape\normalsize} 

\setcounter{secnumdepth}{0}

\renewcommand{\th}[0]{\textsuperscript{th}}
\newcommand{\st}[0]{\textsuperscript{st}}
\newcommand{\nd}[0]{\textsuperscript{nd}}
\newcommand{\rd}[1]{\textsuperscript{rd}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\mieds}[0]{\textsc{MIEDS}}
\begin{document}

\input{title}
\doublespacing

\section{Simulator Description}

The \mieds{} simulator works by initializing the animation, scheduling
the first events, and then looping through all events, processing each
and updating the animation, until either no events remain or time is
exceeded.  The key data structure is \code{Simulation_State_Type}, a
record containing the current time, event queue, AST of the \mieds{}
source code, emplaced hazards, and currently enroute friends.

\subsection{Scheduling Initial Events}

\code{Schedule_Initial_Events} works by processing instances in the
model section of the \mieds{} sourcecode.  The instance is either a
trip or threat.  First, the start time is calculated with
\code{Find_Trip_Schedule_Start} or \code{Find_Threat_Schedule_Start},
both of which simply lookup start times contained in the associated
records.  Then, the event is added to the simulation state using
\code{Schedule_Trip_Start} or \code{Schedule_Hazard}.  This process is
repeated for all instances in the \mieds{} source code.

\subsection{Looping and Processing Events}

The simulation runs until the simulation state time exceeds the stop
time, which is defined as the last real number
(i.e. \code{Real'Last}), or until the simulation state event queue is
empty.  During each iteration, first, the next event is popped from
the queue by \code{Get_Next_Event}.  Second, the state simulation
time, \code{State.Time} is set to the current \code{Event.Time}.
Third, the current event is processed by calling the polymorphic
procedure \code{Handle}, which is defined for \code{Trip_Start_Type},
\code{Friend_Movement_Type}, \code{Hazard_Emplacement_Type} and
\code{Hazard_Removal_Type} events.  Fourth, the memory for the event
is deallocated.  Finally, the animation is updated with current
simulation state.

\subsection{Event Handlers}
The trip start \code{Handle} procedure first appends the trip start
event to \code{State.Friend_Enroute}, a doubly linked list of
\code{Friend_Enroute_Type}.  Second, \code{Handle} increments
\code{Next_Friend_Enroute_ID}.  Third, the initial trip movement is
scheduled with \code{Schedule_Friend_Movement}, which allocates a new
\code{Friend_Movement_Type} with the correct time and inserts it into
\code{State.Event_Queue}.  Finally, if the trip is cyclic (i.e. has an
interval greater than 0.0, as calculated by
\code{Find_Trip_Schedule_Interval}) then the next trip is scheduled
for time \code{Event.Time + Interval}.

The friend movement \code{Handle} procedure first calculates the
\code{Native_Speed} of the friend using \code{Find_Friend_Speed},
which lookups the expression from the \mieds{} AST.  Second,
\code{Handle} advances the friend along its route using
\code{Advance}, which ultimately determines where the friend moves.
In order of operation, \code{Advance} computes the inital segement,
checks for stoppers, checks for route completion, updates the friend
position and checks for stoppage during a partial traversal.  If the
friend trip \code{Is_Complete} then it is deleted from
\code{State.Friends_Enroute}, else
\code{Friend_Enroute.Last_Update_Time} is set to the current time, the
friend enroute data is replaced with the new data and the next
movement is scheduled.

The hazard emplacement \code{Handle} first determines the duration of
the hazard with \code{Find_Threat_Duration}.  Next, \code{Handle}
initializes and randomly sets the hazard location with
\code{Get_Random_Point}.  If the hazard is still viable
(\code{Duration > 0.0}), then an empty hazard is created and appended
to \code{State.Hazards} as a placeholder,
\code{Schedule_Hazard_Removal} schedules the removal event for the
hazards, and the placeholder hazards is replaced with the actual
hazard.  If the hazards is not viable and scheduled to be removed,
then hazards is simply appended to \code{State.Hazards}.  Finally, if
the the hazard is viable and cyclic (i.e. \code{Interval > 0.0}) then
the next cycle is scheduled with \code{Schedule_Hazard} for time
\code{Event.Time + Interval}.

The hazard removal \code{Handle} simply deletes the hazard from
\code{State.Hazards}, a doubly-linked list of emplaced hazards.

\subsection{Event Deallocation}

An instance of \code{Ada.Unchecked_Deallocation} named \code{Free} is
used to delete already processed events to prevent memory leaks.


\section{Changed Data Structures and Code}

If a friend moves within 10 meters of a hazard, the hazard detonates
and is immediately removed from the scenario.  The friend is hurt with
probability = (friend vulnerability * hazard effectiveness).  For
example, if the friend is of maximum vulnerability 1 and the hazard is
of maximum effectiveness 1, then the friend is certainly hurt.  If the
friend is hurt, it is immediately removed from the scenario.

\section{Changes to Data Structures}
1. changes to data structures


\section{Changes to Code}
2. changes to code that must be made in order to implement the desired
simulator function.

First, we must determine if a friend is within ten meters of a hazard,
a problem commonly known as collision detection.  The naive alogrithm
of comparing each friend to each hazard has a time complexity of
$O(n^2)$, but should be suitable for the vast majority of simulations.
The natural place for detection is in a new procedure
\code{Friend_Is_Hurt} which is called from \code{Handle} for friend
movement before the call to \code{Advance}.  We use an out parameter
\code{Is_Hurt} as a boolean flag to signal that the friend is hurt.

\subsection{Friend_Is_Hurt Definition}
\code{Friend_Is_Hurt} takes three parameters, \code{Friend_Enroute} as
defined in \code{Handle}, \code{State.Hazards} which is in scope, and
the out parameter \code{Is_Hurt}.  We loop through the hazards using
the \code{Iterate} procedure, each time checking to see if the
distance between the friend and current hazard is less than ten
meters.  We employ the distance formula using the point locations of
the friend and current hazard as $x$ and $y$.

\[distance = \sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}\]

To obtain the point locations we use the predefined location fields
for \code{Friend_Enroute_Type} and \code{Emplaced_Hazard_Type}.  To
determine if a friend is hurt by a hazard we need a random number
generator, the friend vulnerability and the hazard effectiveness.
\code{Ada.Numerics.Float_Random} is already in scope and provides
random floats between 0.0 and 1.0.  We simply instaniate a
\code{Generator} and call \code{Random} with the
generator. \code{Find_Friend_Vulnerability} is already defined.
\code{Find_Threat_Effectiveness} is defined in the \code{ast-tree}
package as an accessor for the \code{Effectiveness} field in
\code{Threat_Type} by using the convenience function
\code{Find_Positive_Value}.  A friend is hurt if $random(generator) <=
vulnerability \cdot effectiveness$.

After determining a friend is hurt, we must remove the friend from
\code{State.Friends_Enroute} and the hazards from
\code{State.Hazards}.  We remove friend by calling \code{FEL.Delete}
with \code{State.Friends_Enroute} and \code{Friend_Enroute_Cursor}
which are previously defined.  We remove the hazard in a similar
manner, calling \code{EHL.Delete} with \code{State.Hazards} and the
current hazard cursor.

\end{document}
